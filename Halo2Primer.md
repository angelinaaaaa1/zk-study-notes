Halo2 Primer
================

Youtube link: https://www.youtube.com/watch?v=W_zlH2mmtZA

## Overview

In a high level, Halo2 proof system consists of 3 components:

arithmetisation --> polynomial commitment scheme --> accumulation scheme

**Arithmetisation**: a way to express some relation and some satisfying witness to the relation as a low degree polynomial. Halo2 uses PLONKish arithmetisation.

**Polynomial Commitment Scheme**: Take the low degree polynomail, commit it to it, and provably evaluate it at challenging points. Halo2 uses inner product argument (there is a KZG verison tho).

**Accumulation Scheme**: Turns the verification of the proof into constant sized accumulator that is efficient to check and the expense of the check is linear to the size of the polynomial to be proven, and this check is amortized on a batch of proofs. That's where Halo2 enables recursion.

## PLONKish arithmetisation

PLONK [GWC19] -> TurboPLONK (with customized gates) [GW19] -> UltraPLONK (with lookup table) [Halo2]

### Vanilla PLONK

gates take two values as input, either add or multiply them, and then emit the result through an output wire.

$q_L \cdot x_a + q_R \cdot x_b + q_0 \cdot x_c + q_M \cdot (x_a x_b) = 0$

where the $q$s are pre-processed polynomials, also called selectors.  They are generated by the verifiers and they are "hardcoded" for your circuits and the $x$s are witted by the provers and have different values in each proving instances.

You could express add and mul just using this vanilla gates:

add: $1 \cdot x_a + 1 \cdot x_b + (-1) \cdot x_c + 0 \cdot (x_a x_b) = 0$
mul: $0 \cdot x_a + 0 \cdot x_b + (-1) \cdot x_c + 1 \cdot (x_a x_b) = 0$


### Custom Gates (TurboPlonk)

Custom gates are composed by arbitrary linear combinations o add, mul, and bool:

$q_{add} \cdot (a_0 + a_1 - a_2) + y \cdot q_{mul} \cdot (a_0 a_1 - a2) + y^2 \cdot q_{bool} \cdot q_{bool} \cdot (a_0 a_0 - a_0) = 0$

where $y$, $y^2$ are verifier generated challenges to keep gates linearly independent.

### Permutation Arguments

What is revolutionary of PLONK (vanilla PLONK) is the permuation arguments that allows us to enforce "global constraints". In the other words, it allows us to "route" the wires together.

- wires carry values into and out of the gates: "global" consistency check: do the wire correctly join the gates together?
  (for example, in Groth16, routing is baked into the trusted setup)

![vanilla-plonk-gate](vanilla_plonk_gate.png)

We can express the vanilla PLONK gates into a "table" as below:

| $w_0$     |   $w_1$    |    $w_2$   |  gate       |
|-----------|------------|------------|-------------| 
| $w_0[0]$  | $w_1[0]$   |  $w_2[0]$  |  $+$        |
| $w_0[1]$  | $w_1[1]$   |  $w_2[1]$  |  $\times$   |

Permutation argument is expressed in the language of Lagrange polynomials and root of unity. (more details later)

Each wire (column) is encoded as a Lagrange polynomial over the powers (rows) of the n-th root of unity $\{ 1, \omega, \ldots, \omega^{n-1} \}$, where $\omega^n = 1$:

$ w_i (\omega^j) = w_i [j] $
